# $\color{FCE6C9}{图的基础知识}$

### **o 术语**
- 顶点 Vertex
 
- 弧 Arc <u , v> .从u到v的弧。u：弧尾；v：弧头

- 边 Edge

- 入度：ID(v) ; 出度：OD(v) ; 度：TD(v)

### **o 存储方法*
- 邻接矩阵
  
  - 无向图只用压缩存储一个三角矩阵即可
  
  - 有向图要全部存储

- 邻接表P219

  - 表头结点表。由所有表头结点以顺序结构(向量)的形式存储,以便可以随机访问任一顶点的边链表。表头结点由两部分构成,其中数据域vexdata用于存储顶点的名或其他有关信息;链域firstarc用于指向链表中第-一个顶点(即与顶点D;邻接的第一个邻接点)。

  - 边表。由表示图中顶点间邻接关系的n个边链表组成。边链表中结点的结构由三部分组成,其中邻接点域adjvex用于存放与顶点D;相邻接的顶点在图中的位置;链域nextarc用于指向与顶点D;相关联的下一条边或弧的结点;数据域info用于存放与边或弧相关的信息(如赋权图中每条边或弧的权值等)。

- 十字链表(OrthogonalList)P221

  - 有向图的另一种链式存储结构,可以把它看成是将有向图的邻接表和逆邻接表结合起来的一种链表。有向图中的每一条弧对应十字链表中的一个弧结点,同时有向图中的每个顶点在十字链表中对应有一个结点,称为顶点结点。

### **o 应用**

- 简单路径

-  有向无环图的应用：《数据结构》P243-249

   1. 拓扑排序：

        + 概念：

          + AOV-网：用顶点表示活动的网。用顶点表示活动，弧表示活动间优先关系

          + 拓扑序列：先后关系的序列（可能不唯一）

        + 思想：

          1. 选取无前驱的节点并记录此节点

          2. 删除此节点和相连的边

          3. 重复，直到不存在没有前驱的节点

          4. 若此时记录的节点小于总节点数，说明有环。否则记录的是一个拓扑排序

        + 基于邻接矩阵G的算法：

          1. 第一个序号k=1

          2. 找一个未新编号且值全为0的列。若找到，继续(3);否则，若所有列都已经编号，排序结束，若还有列没有编号，则存在回路
          
          3. 输出(2)找到的列对应的顶点j，把新序号k赋给(2)中找到的列
          
          4. j对应的行全部置为0
          
          5. 序号k++，转(2)
        
        + 基于邻接表G的算法：
        
          1. 查找indegree[i]为0的顶点i
        
          2. 对链在i后面的所有邻接顶点j，对应的indegree[j]减一
        
          3. 为避免重复检测入度为0的点，设一辅助栈S，将入度为0的顶点入栈。
        
          4. 只要栈不空，重复：{栈顶元素i出栈并打印 -> i的每个邻接点k的入度减1，若k入度变为0，k入栈}

   2. 关键路径
        + 概念：

          + AOE-网：边表示活动的网。用顶点表示时间，边的权值表示所需时间（记顶点为v，边为a，即通常事件为v，活动为a）

          + 源点：唯一的、入度为0的节点

          + 汇点：唯一的、出度为0的节点

          + 关键路径：从源点到汇点的最长路径长度即是完成活动所需的总时间（即：最长路径=最短路径）

          + 关键活动：关键路径上的活动

          + 事件v的最早发生时间：源点到v的最长路径长度

          + 事件v的最晚发生时间（在保证汇点最早发生的前提下）：从汇点开始，逆拓扑顺序向源点递推      

          + 活动a开始的最早时间：从源点到弧a的始点最长路径

          + 活动a开始的最晚时间：倒推

          + 活动a松弛时间（时间余量）：a的最早开始时间与最晚开始时间之差
           
        + 关键路径步骤：

          1. 进行拓扑排序，排序时按照拓扑序列求出每个事件的最早发生时间ve(i)（程序如上）

          2. 按照逆拓扑序列求出事件最晚发生时间vl(i)

          3. 求出每个活动a(i)的最早开始时间e(i)和最晚发生时间l(i)

          4. e(i)=l(i)为所求

        + 算法思想：(部分功能已在TopOrder实现)
         
          1. 求出各个顶点入度，入度为0则入栈S
           
          3. 初始化各顶点最早发生时间为ve[i]=0
           
          4. 当栈S不空，重复：
              1. S栈顶元素j出栈，并压入T（生成逆拓扑序列）
               
              2. 对链在j后面的所有邻接顶点k，对应的indegree[k]减一。若此时入度为0，则对应节点入栈S
               
              3. 根据顶点j的最早发生时间和ve[j]和弧<j,k>的权值，更新k的最早发生时间

- 遍历 P225-231

  - 广度优先（队列）

  - 深度优先（栈）

- 生成树和最小生成树

  - 概念：
    - 生成树：一个连通图的生成树是指一个极小连通子图,它含有图中的全部顶点,但只有足以构成一棵树的n-1条边,如图7.5所示。如果在一棵生成树上添加一条边,必定构成一个环,这是因为该条边使得它依附的两个顶点之间有了第二条路径
  
    - 最小生成树：各边的代价之和最小的生成树（MST)

  - 算法：
    - Prim：普里姆算法(最小生成树，加点法)
      - 假设N=(V,{E})是连通网，TE是最小生成树中边的集合
        1. 初始U={u0}（u0属于V），TE为空集
         
        2. 在所有的u属于U，v属于V-U的边中选一条代价最小的边放进TE，v0放进U
        
        3. 重复(2)直到U=V
        - 此时，TE中有n-1条边，则T必然是N的最小生成树
      - 算法步骤：
          1. 初始顶点u加入集合U，剩余的每个顶点i，将CloseEdge[i]初始化为i到u的边信息
          
          2. 循环n-1次：
             1. 从各组最小边CloseEdge[]里选择最小的最小边ClodeEdge[v]（v属于V-U）
            
             2. v加入U
            
             3. 更新剩余节点的最小边信息CloseEdge[i]（i属于V-U）
