# $\color{#FCE6C9}{树的基础知识}$

### **o 相关术语**
- 结点的度:一个结点的子树个数称为此结点的度。

- 叶结点:度为0的结点,即无后继的结点,也称为终端结点。

- 分支结点:度不为0的结点,也称为非终端结点。

- 结点的层次:从根结点开始定义,根结点的层次为1, 根的直接后继的层次为2,以此类推。

- 结点的层序编号:将树中的结点按从上层到下层、同层从左到右的次序排成一个线性序列,依次给它们编以连续的自然数。

- 树的度:树中所有结点的度的最大值。</br></br>

- 树的高度(深度):树中所有结点的层次的最大值。

- 有序树:在树T中,如果各子树T之间是有先后次序的，则称为有序树。

- 森林:m(m≥0)棵互不相交的树的集合。将一棵非空树的根结点删去,树就变成一个森林;反之,给森林增加一个统一的根结点,森林就变成一棵树。

- 同构:对两棵树,通过对结点适当地重命名,就可以使两棵树完全相等(结点对应相等,对应结点的相关关系也相等) ,则称这两棵树同构。</br></br>

- 兄弟结点:同一双亲结点的孩子结点之间互称兄弟结点。

- 堂兄弟:父亲是兄弟关系或堂兄关系的结点称为堂兄弟结点。

- 祖先结点:一个结点的祖先结点是指从根结点到该结点的路径上的所有结点。

- 子孙结点:一个结点的直接后继和间接后继称为该结点的子孙结点。

- 前辈:层号比该结点小的结点,都称为该结点的前辈。

- 后辈:层号比该结点大的结点,都称为该结点的后辈。

### **o 二叉树的性质**
- 二叉树的第i层至多有 $2^{i-1}$ 个节点（i≥1）
- 深度为k的二叉树至多有 $2^k-1$ 个节点（k≥1）
- 若终端节点树为 $n_{0}$ ,而度数为2的节点数为 $n_{2}$ ,则 $n_{0} = n_{2} + 1$
- 由遍历序列唯一确定一颗二叉树，必须为中序遍历和先/后序遍历共同确定，先序和后序不行
- 树的先根遍历<-->对应二叉树的前序遍历
- 书的后根遍历<-->对应二叉树的中序遍历
### **o 满二叉树**
- 定义：深度为k的二叉树，且有 $2^k-1$ 个节点
- 顺序表示：从根开始，层次贱从上至下、层次内从左到右编号

### **o 完全二叉树**
- 定义：深度为k，节点数为n的二叉树，其节点1~n的位置序号分别于等高的满二叉树的节点1~n的序号一一对应
- 性质：对于具有n个结点的完全二叉树,如果按照从上到下和从左到右的顺序对二叉树中的所有结点从1开始顺序编号,则对于任意的序号为i的结点有:
  1. 如 i=1 ,则序号为 i 的结点是根结点, 无双亲结点; 如 i>1 ,则序号为i的结点的双亲结点序号为 i/2
  
  2. 如 2i>n ,则序号为 i 的结点无左孩子; 如 2i≤n ,则序号为i的结点的左孩子结点的序号为 2i。
  
  3. 如 2i+1>n ,则序号为 i 的结点无右孩子; 如 2i+1≤n ,则序号为i的结点的右孩子结点的序号为 2i+1。

### **o 树的存储**
1. 存储结构
  
  - 顺序存储（仅针对完全二叉树）
  - 链式存储

2. 存储方法（教材P181-182）
  
  - 双亲表示法
  - 孩子表示法
  - 孩子兄弟表示法
  
### **o 线索二叉树**

- Ltag/Rtag = 0 ：指针域指向左/右孩子

- Ltag = 1 ：指针域指向节点的遍历前驱

- Rtag = 1 ：指针域指向节点的遍历后继
  </br></br>
  *注：遍历前驱/后继，指的是在遍历（打印）时该节点的前/后一个节点，而非逻辑结构上的前驱/后继*

### **o 哈夫曼树和哈夫曼编码**
- 节点的带权路径长度：从树根到某节点的路径长度乘上节点的权重。

- 树的带权节点权重：所以 叶子 节点的带权路径和

- 霍夫曼树：n个带权叶子节点的构成的所有二叉树中带权路径长度最短的二叉树（也称最优二叉树）

- 构建过程：
    1. 初始化:用给定的n个权值{w1,w2,... ,wn}构造n棵二叉树并构成的森林F={T1,T2,T3,Tn},其中每棵二叉树Ti(1≤i≤n)都只有一个权值为wi的根结点,其左、右子树为空。

    2. 找最小树:在森林F中选择两棵根结点权值最小的二叉树,作为一棵新二叉树的左、右子树,标记新二叉树的根结点权值为其左、右子树的根结点权值之和。

    3. 删除与加入:从F中删除被选中的那两棵二叉树,同时把新构成的二叉树加人到森林F中。

    4. 重复，直到森林只有一棵树

    + 简而言之，先选择权小的,所以权小的结点被放置在树的较深层,而权较大的离根较近,故在哈夫曼树中权越大叶子离根越近，这样一来,在计算树的带权路径长度时,自然会具有最小带权路径长度,这种生成算法就是一种典型的贪心法。

- 前缀编码：任何一个编码不是另一个编码的前缀

- 哈夫曼编码：

    1. 创建Huffman编码:左子树为1, 右子树为0, 从根节点到该节点的数字连起来(二进制)就是对应的编码.

    2. 哈夫曼编码是前缀编码
     
    4. 编码中1的个数等于路过的路径数