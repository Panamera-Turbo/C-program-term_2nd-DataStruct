#include "../record.h"
/*********************************************************************
 * 堆排序：
 * 采用堆排序时,只需要一个记录大小的辅助空间。堆排序是在排序过程中,将向
 * 量中存储的数据看成一棵完全二叉树,利用完全二叉树中双亲结点和孩子结点之
 * 间的内在关系来选择关键字最小的记录，即待排序记录仍采用向量数组方式存
 * 储,并非采用树的存储结构，而仅仅是采用完全二叉树的顺序结构的特征进行分
 * 析而已。
 * 
 * --------------------------------------------------------------------
 * 【算法思想】
 * 把待排序的记录的关键字存放在数组r[1..n]之中,将r看成是一棵完全二叉树的
 * 顺序表示，每个结点表示一个记录,第一个记录r[1]作为二叉树的根,以下各记录
 * r[2]~r[n]依次逐层从左到右顺序排列,任意结点r[i]的左孩子是r[2i],右孩
 * 子是r[2i+1],双亲是r[i/2]。对这棵完全二叉树进行调整建堆。
 * 
 * -------------------------------------------------------------------
 * 大根堆：双亲大于子节点，左孩子大于右孩子，反之则为小根堆
 * 
 * 【算法步骤】
 * 
 * 【1】建初堆
 *    将一个任意序列看成是对应的完全二叉树,由 于叶结点可以视为单元素的堆,因而
 *    可以反复利用下面的调整堆算法(“筛选”法),自底向上逐层把所有子树调整为堆,直
 *    到将整个完全二叉树调整为堆。可以证明，上述完全二叉树中,最后一个非叶结点
 *    位于第n/2个位置,n为二叉树结点数目。因此,“筛选”需从第n/2个结点开始,逐层
 *    向上倒退,直到根结点。

 * 【2】重建堆
 * 当堆顶记录改变时,按照如下步骤重建堆：
 *  1)首先将与堆相应的完全二叉树根结点中的记录移出,该记录称为待调整记录。
 *    此时根结点相当于空结点;
 *  2)从空结点的左、右子树中选出一个关键字较大的记录,如果该记录的关键字大
 *    于待调整记录的关键字,则将该记录上移至空结点中。此时,原来那个关键字较大
 *    的子结点相当于空结点;
 *  3)从空结点的左、右子树中选出一个关键字较大的记录,如果该记录的关键字仍大
 *    于待调整记录的关键字，则将该记录上移至空结点中。重复上述移动过程，直到
 *    空结点左、右子树的关键字均小于待调整记录的关键字。
 *  4)将待调整记录放入空结点即可。
 * 
 * **********************************************************************/

static void sift(RecordType r[], int k, int m)
{/*假设ｒ[k..m]是以ｒ[k]为根的完全二叉树，且分别以ｒ[2k]和ｒ[2k+1]为根的左、右子树为
   大根堆，调整r[k]，使整个序列r[k..m]满足堆的性质*/
    RecordType t = r[k]; /* 暂存"根"记录r[k] */
    bool finished = false;

    int i = k;      //i是子树的根节点序号
    int j = 2 * i;  //初始时，j是i的左孩子序号
    //沿着i的孩子j，往下筛选
    while (j <= m && !finished)
    {
        if (j < m && r[j].key < r[j + 1].key)   //j+1是i右孩子的序号
            ++j;                          //若存在右子树，且右子树根的关键字大，则沿右分支"筛选"
            
        if (t.key >= r[j].key)  finished = true;    //筛选完毕
        else if(t.key < r[j].key)
        {
            r[i] = r[j]; //子树的根节点被其值最大的那个孩子覆盖
            i = j;   //以j为子树的根，进行下一趟筛选
            j = 2 * i;
        } /* 继续筛选 */
    }
    //i已经不再是原来的i，而是原来的某个深度的孩子的序号
    r[i] = t; /* 原来的根r[k]填入到恰当的位置 */
}
//-----------------------------------------------------------------------------------------
static void create_heap(RecordType r[], int length)
{/*对记录数组r建初堆，length为数组的长度*/
    for(int i = length / 2; i >= 1; --i) /* 自第[n/2]个记录开始进行筛选建堆 */
        sift(r, i, length);
}

//-----------------------------------------------------------------------------------------
void HeapSort(RecordType r[], int length)
{/* 对r[1..n]进行堆排序，执行本算法后，r中记录按关键字由大到小有序排列 */
    RecordType b;

    create_heap(r, length);

    for (int i = length; i >= 2; --i)
    {
        /* 将堆顶记录和堆中的最后一个记录互换 */
        b = r[1];
        r[1] = r[i];
        r[i] = b;

        /* 进行调整，使r[1..i-1]变成堆 */
        sift(r, 1, i - 1);
    }
} /* HeapSort */