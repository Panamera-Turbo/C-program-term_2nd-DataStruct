#include "../record.h"
/****************************************************************
 * -------------------------快速排序----------------------------
 * 
 * 算法思想:
 * 从待排序记录序列中选取一个记录(通常选取第一个记录)为枢轴,
 * 其关键字设为K,然后将其余关键字小于K,的记录移到前面,而将关键字大于或
 * 等于K的记录移到后面，结果将待排序记录序列分成两个子表,最后将关键字为
 * K的记录插到其分界线的位置处。将这个过程称为一趟快速排序。 通过一次划
 * 分后 ，就以关键字为 K，的记录为界,将待排序序列分成了两个子表,且前面
 * 子表中所有记录的关键字均小于K,而后面子表中的所有记录的关键字均大于或
 * 等于K。对分割后的子表继续按上述原则进行分割，直到所有子表的表长不超
 * 过1为止，此时待排序记录序列就变成了一个有序表。
 * --------------------------------------------------------------
 * 算法步骤：
 * 假设待划分序列为 r[low], r[low+1], ... ,r[high]。首先将基准记录
 * r[low]移至变量x中，使r[low]相当于空单元，然后反复进行如下两个扫描
 * 过程，直到low和high相遇。
 * 
 * 【1】high从右向左扫描，直到r[high].key<x.key时,将r[high]移至空单
 * 元r[low]，此时r[high]相当于空单元。
 * 【2】low从左向右扫描，直到r[low]. key≥x. key时,将τ[ low]移至空单
 * 元r[ high],此时r[ low]相当于空单元。
 * 【3】当low和high相遇时，r[low](或r[ high])相当于空单元，且r[low]
 * 左边所有记录的关键字均小于基准记录的关键字,而r[low]右边所有记录的关
 * 键字均大于或等于基准记录的关键字。最后将基准记录移至r[low]中，就完成
 * 了一次划分过程。对于r[low]左边的子表和r[low]右边的子表可采用同样的方
 * 法进行进一一步划分。
 * --------------------------------------------------------------
 * 时间复杂度：近似于O(nlogn)
 * 排序不具有稳定性
 * ********************************************************/

static int Pivot(RecordType r[], int low, int high)
/*对记录数组r 中的r[left]至r[right]部分进行一趟排序，并得到基准的位置，
  使得排序后的结果满足其之后（前）的记录的关键字均不小于（大于）于基准记录*/
{
    RecordType x = r[low]; /* 选择基准记录*/

    while (low < high)
    {
        while (low < high && r[high].key >= x.key) /* high从右到左找小于x.key的记录 */
            --high;

        if (low < high) //用if来保护，确保high大于low
        {
            r[low] = r[high];
            ++low;
        }

        /* 找到小于x.key的记录，则进行交换*/
        while (low < high && r[low].key < x.key) /* low从左到右找大于x.key的记录 */
            ++low;
        if (low < high)
        {
            r[high] = r[low];
            --high;
        } /* 找到大于x.key的记录，则交换*/
    }

    r[low] = x; /*将基准记录保存到low=high的位置*/
    return low; /*返回基准记录的位置*/
} 

static void _QuickSort_(RecordType r[], int low, int high)
/*对记录数组r[low..high]用快速排序算法进行排序*/
{
    if (low < high)
    {
        int pivot = Pivot(r, low, high); /*调用一趟快速排序，将枢轴元素为界划分两个子表*/
        _QuickSort_(r, low, pivot - 1);	/*对左部子表快速排序*/
        _QuickSort_(r, pivot + 1, high);	/*对右部子表快速排序*/
    }
}

void QuickSort(RecordType r[], int length) // wrapper
{
    _QuickSort_(r, 1, length);
}